<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · TensorNetworkAD.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TensorNetworkAD.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>User Guide</a><ul class="internal"><li><a class="toctext" href="#Tensor-Renormalization-Group-1">Tensor Renormalization Group</a></li><li><a class="toctext" href="#Corner-Tensor-Renormalization-Group-1">Corner Tensor Renormalization Group</a></li><li><a class="toctext" href="#Variational-Ipeps-Optimisation-1">Variational Ipeps Optimisation</a></li></ul></li><li><a class="toctext" href="../docstrings/">Doc-Strings</a></li><li><a class="toctext" href="../future/">Future Directions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User Guide</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/master/docs/src/userguide.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><p>The package provides three algorithms: <code>trg</code>, <code>ctmrg</code> and <code>variationalipeps</code>-optimisation.</p><h2><a class="nav-anchor" id="Tensor-Renormalization-Group-1" href="#Tensor-Renormalization-Group-1">Tensor Renormalization Group</a></h2><p>The <code>trg</code> function can currently be used to get the partition function of a classical hamiltonian model on a square lattice. <code>trg</code> uses the principle of <em>coarse graining</em> - low-level detail is discarded in favor of dynamics that dominate the big picture. For an excellent guide to implement <code>trg</code>, check out <a href="https://itensor.org/docs.cgi?page=book/trg">this tutorial for <code>iTensor</code></a>.</p><p>The input to <code>trg</code> is a rank-4 tensor <code>a</code> that is the tensor-network representation of a model, a cutoff-dimension <code>χ</code> and a number of iterations <code>niter</code>. <code>trg(a, χ, niter)</code> returns the partition function <em>per site</em>.</p><p>The result is per site because otherwise the partition function grows exponentially (with the system size) in the number of iterations, leading to numerical problems quickly.</p><p>The <code>trg</code> algorithm is fully differentiable with <code>Zygote</code>, which enables us to directly find the first derivative of the partition function with:</p><pre><code class="language-julia">julia&gt; using Zygote, TensorNetworkAD

julia&gt; Zygote.gradient(0.5) do β
          trg(model_tensor(Ising(), β), 5, 5)
        end
(1.7502426939979507,)</code></pre><p>where we take the derivative of the ising-partition function w.r.t the inverse temperature <code>β</code> using the <code>model_tensor</code> function provided by <code>TensorNetworkAD</code>.</p><h2><a class="nav-anchor" id="Corner-Tensor-Renormalization-Group-1" href="#Corner-Tensor-Renormalization-Group-1">Corner Tensor Renormalization Group</a></h2><p>The <code>ctmrg</code> function can be used to find a representation of the environment of an ipeps. The environment can then be used to calculate local quantities for a system of infinite size such as the magnetisation or (short) correlation-lengths. For an introduction, I&#39;d recommend  an <a href="https://arxiv.org/pdf/0905.3225.pdf">overview paper by Roman Orus</a>.</p><p>To use the function, first whatever tensor represents the <code>bulk</code> of the ipeps needs to be wrapped in a <code>CTMRGRuntime</code> structure which takes care of initializing the environment - either randomly or from the <code>bulk</code> tensor. Currently, there&#39;s only one <code>CTMRGRuntime</code> implemented which assumes a bulk-tensor which is invariant under any permutation of its virtual indices.</p><p>The runtime-object can then be provided to <code>ctmrg</code> together with a limit to the number of iterations <code>maxit</code> and a tolerance <code>tol</code>. The latter is used to decide convergence - if the sum of absolute differences in consecutive singular values of the corner is less than <code>tol</code>, the algorithm is converged.</p><p>A complete example to get the environment of the Ising model is</p><pre><code class="language-julia">julia&gt; a = model_tensor(Ising(),0.4);
julia&gt; rt = SquareCTMRGRuntime(a, Val(:random), 10);
julia&gt; rt = ctmrg(rt; tol=1e-6, maxit=100);
julia&gt; corner, edge = rt.corner, rt.edge;</code></pre><p>where <code>Val(:random)</code> is used to have the environment initialized with random values.</p><h2><a class="nav-anchor" id="Variational-Ipeps-Optimisation-1" href="#Variational-Ipeps-Optimisation-1">Variational Ipeps Optimisation</a></h2><p>Variational Ipeps Optimisation works by combining <code>ctmrg</code>, automatic differentiation by <code>Zygote</code> and optimisation by <code>Optim</code>. The central function is rather simple and can be found in <code>variationalipeps.jl</code>.</p><p>We provide the function <code>optimiseipeps</code> with an <code>IPEPS</code>-object - a thin wrapper around a rank-5 tensor - and minimize the energy function with <code>Optim</code> using the gradient calculated by <code>Zygote</code>. Energy calculation is built on <code>ctmrg</code> so we need to supply its arguments: χ, tol and maxit but we might also modify the optimization algorithm using <code>optimmethod</code> or <code>optimargs</code>. <code>optimargs</code> can be used to e.g. print out the current energy at each step with <code>optimargs = (show_trace = true,)</code>.</p><p>The convergence is judged by <code>Optim</code> and can be modified with <code>optimargs</code>. A complete example looks like:</p><pre><code class="language-julia">julia&gt; using Optim
julia&gt; h = hamiltonian(TFIsing(1.0))
julia&gt; ipeps = SquareIPEPS(randn(2,2,2,2,2))
julia&gt; ipeps = TensorNetworkAD.indexperm_symmetrize(ipeps)
julia&gt; res = optimiseipeps(ipeps, h; χ=5, tol=0, maxit=100,
        optimargs = (Optim.Options(f_tol=1e-6, show_trace=true),))
julia&gt; e = minimum(res)</code></pre><p>where we get the hamiltonian <code>h</code> of the transverse field ising model with magnetic field <code>hx = 1</code>, then we create a random initial <code>ipeps</code> with the necessary symmetry and then minimize its energy with with <code>optimiseipeps</code> where we consider it converged if the energy changes by less than <code>1e-6</code> between two iterations and we print the energy at each timestep. The ground-state energy is saved in <code>e</code> in the last line.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../docstrings/"><span class="direction">Next</span><span class="title">Doc-Strings</span></a></footer></article></body></html>

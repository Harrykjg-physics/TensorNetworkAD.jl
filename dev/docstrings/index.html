<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Doc-Strings · TensorNetworkAD.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TensorNetworkAD.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../userguide/">User Guide</a></li><li class="current"><a class="toctext" href>Doc-Strings</a><ul class="internal"></ul></li><li><a class="toctext" href="../future/">Future Directions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Doc-Strings</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/master/docs/src/docstrings.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Doc-Strings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.CTMRGRuntime" href="#TensorNetworkAD.CTMRGRuntime"><code>TensorNetworkAD.CTMRGRuntime</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CTMRGRuntime{LT}</code></pre><p>a struct to hold the tensors during the <code>ctmrg</code> algorithm, containing</p><ul><li><code>D × D × D × D</code> <code>bulk</code> tensor</li><li><code>χ × χ</code> <code>corner</code> tensor</li><li><code>χ × D × χ</code> <code>edge</code> tensor</li></ul><p>and <code>LT</code> is a AbstractLattice to define the lattice type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ctmrg.jl#LL14-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.Heisenberg" href="#TensorNetworkAD.Heisenberg"><code>TensorNetworkAD.Heisenberg</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Heisenberg(Jz::T,Jx::T,Jy::T) where {T&lt;:Real}</code></pre><p>return a struct representing the heisenberg model with magnetisation fields <code>Jz</code>, <code>Jx</code> and <code>Jy</code>..</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/hamiltonianmodels.jl#LL35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.IPEPS" href="#TensorNetworkAD.IPEPS"><code>TensorNetworkAD.IPEPS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IPEPS{LT&lt;:AbstractLattice, T, N}</code></pre><p>Infinite projected entangled pair of states. <code>LT</code> is the type of lattice, <code>T</code> and <code>N</code> are bulk tensor element type and order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ipeps.jl#LL2-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.SquareCTMRGRuntime-Union{Tuple{T}, Tuple{AbstractArray{T,4},Val,Int64}} where T" href="#TensorNetworkAD.SquareCTMRGRuntime-Union{Tuple{T}, Tuple{AbstractArray{T,4},Val,Int64}} where T"><code>TensorNetworkAD.SquareCTMRGRuntime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SquareCTMRGRuntime(bulk::AbstractArray{T,4}, env::Val, χ::Int)</code></pre><p>create a <code>SquareCTMRGRuntime</code> with bulk-tensor <code>bulk</code>. The corner and edge tensors are initialized according to <code>env</code>. If <code>env = Val(:random)</code>, the corner is initialized as a random χ×χ tensor and the edge is initialized as a random χ×D×χ tensor where <code>D = size(bulk,1)</code>. If <code>env = Val(:raw)</code>, corner- and edge-tensor are initialized by summing over one or two indices of <code>bulk</code> respectively and embedding the result in zeros-tensors of the appropriate size, truncating if necessary.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; rt = SquareCTMRGRuntime(randn(2,2,2,2), Val(:raw), 4);

julia&gt; rt.corner[1:2,1:2] ≈ dropdims(sum(rt.bulk, dims = (3,4)), dims = (3,4))
true

julia&gt; rt.edge[1:2,1:2,1:2] ≈ dropdims(sum(rt.bulk, dims = 4), dims = 4)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ctmrg.jl#LL39-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.TFIsing" href="#TensorNetworkAD.TFIsing"><code>TensorNetworkAD.TFIsing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TFIsing(hx::Real)</code></pre><p>return a struct representing the transverse field ising model with magnetisation <code>hx</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/hamiltonianmodels.jl#LL13-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.ctmrg-Tuple{CTMRGRuntime}" href="#TensorNetworkAD.ctmrg-Tuple{CTMRGRuntime}"><code>TensorNetworkAD.ctmrg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ctmrg(rt::CTMRGRuntime; tol, maxit)</code></pre><p>return a <code>CTMRGRuntime</code> with an environment consisting of corner and edge tensor that have either been iterated for <code>maxit</code> iterations or converged according to <code>tol</code>. Convergence is tested by looking at the sum of the absolut differences in the corner singular values. If it is less than <code>tol</code>, convergence is reached.</p><p><strong>example</strong></p><pre><code class="language-none">julia&gt; a = model_tensor(Ising(),β);

julia&gt; rt = SquareCTMRGRuntime(a, Val(:random), χ);

julia&gt; env = ctmrg(rt; tol=1e-6, maxit=100);</code></pre><p>for the environment of an isingmodel at inverse temperature β on an infinite square lattice.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ctmrg.jl#LL89-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.hamiltonian" href="#TensorNetworkAD.hamiltonian"><code>TensorNetworkAD.hamiltonian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hamiltonian(model&lt;:HamiltonianModel)</code></pre><p>return the hamiltonian of the <code>model</code> as a two-site tensor operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/hamiltonianmodels.jl#LL4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.hamiltonian-Tuple{Heisenberg}" href="#TensorNetworkAD.hamiltonian-Tuple{Heisenberg}"><code>TensorNetworkAD.hamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hamiltonian(model::Heisenberg)</code></pre><p>return the heisenberg hamiltonian for the <code>model</code> as a two-site operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/hamiltonianmodels.jl#LL48-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.hamiltonian-Tuple{TFIsing}" href="#TensorNetworkAD.hamiltonian-Tuple{TFIsing}"><code>TensorNetworkAD.hamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hamiltonian(model::TFIsing)</code></pre><p>return the transverse field ising hamiltonian for the provided <code>model</code> as a two-site operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/hamiltonianmodels.jl#LL22-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.mag_tensor-Tuple{Ising,Any}" href="#TensorNetworkAD.mag_tensor-Tuple{Ising,Any}"><code>TensorNetworkAD.mag_tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mag_tensor(::Ising,β)</code></pre><p>return the operator for the magnetisation at inverse temperature <code>β</code> at a site in the two-dimensional ising model on a square lattice in tensor-network form.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/exampletensors.jl#LL37-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.model_tensor-Tuple{Ising,Real}" href="#TensorNetworkAD.model_tensor-Tuple{Ising,Real}"><code>TensorNetworkAD.model_tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">model_tensor(::Ising,β)</code></pre><p>return the isingtensor at inverse temperature <code>β</code> for a two-dimensional square lattice tensor-network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/exampletensors.jl#LL24-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.num_grad-Tuple{Any,AbstractArray}" href="#TensorNetworkAD.num_grad-Tuple{Any,AbstractArray}"><code>TensorNetworkAD.num_grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_grad(f, K::AbstractArray; [δ = 1e-5])</code></pre><p>return the numerical gradient of <code>f</code> for each element of <code>K</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; TensorNetworkAD.num_grad(tr, rand(2,2)) ≈ I
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/autodiff.jl#LL46-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.num_grad-Tuple{Any,Real}" href="#TensorNetworkAD.num_grad-Tuple{Any,Real}"><code>TensorNetworkAD.num_grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_grad(f, K::Real; [δ = 1e-5])</code></pre><p>return the numerical gradient of <code>f</code> at <code>K</code> calculated with <code>(f(K+δ/2) - f(K-δ/2))/δ</code></p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; TensorNetworkAD.num_grad(x -&gt; x * x, 3) ≈ 6
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/autodiff.jl#LL31-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.optimiseipeps-Union{Tuple{LT}, Tuple{IPEPS{LT,T,N,AT} where AT&lt;:AbstractArray{T,N} where N where T,Any}} where LT" href="#TensorNetworkAD.optimiseipeps-Union{Tuple{LT}, Tuple{IPEPS{LT,T,N,AT} where AT&lt;:AbstractArray{T,N} where N where T,Any}} where LT"><code>TensorNetworkAD.optimiseipeps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimiseipeps(ipeps, h; χ, tol, maxit, optimargs = (), optimmethod = LBFGS(m = 20))</code></pre><p>return the tensor <code>bulk&#39;</code> that describes an ipeps that minimises the energy of the two-site hamiltonian <code>h</code>. The minimization is done using <code>Optim</code> with default-method <code>LBFGS</code>. Alternative methods can be specified by loading <code>LineSearches</code> and providing <code>optimmethod</code>. Other options to optim can be passed with <code>optimargs</code>. The energy is calculated using ctmrg with parameters <code>χ</code>, <code>tol</code> and <code>maxit</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/variationalipeps.jl#LL58-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.trg-Union{Tuple{T}, Tuple{AbstractArray{T,4},Any,Any}} where T" href="#TensorNetworkAD.trg-Union{Tuple{T}, Tuple{AbstractArray{T,4},Any,Any}} where T"><code>TensorNetworkAD.trg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">trg(a, χ, niter)</code></pre><p>return the partition-function of a two-dimensional system of size <code>2^niter</code> described by the tensor <code>a</code> calculated via the tensor renormalization group algorithm. <code>a</code> is a rank-4 tensor with the following indices:</p><pre><code class="language-none">    |1
4--[a]--2
   3|</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/trg.jl#LL4-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.StopFunction-Tuple{Any}" href="#TensorNetworkAD.StopFunction-Tuple{Any}"><code>TensorNetworkAD.StopFunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(st::StopFunction)(state)</code></pre><p>stopfunction for ctmrg, returning true if singular values are converged or the maximum number of iterations is reached. Implemented as a closure since it needs to remember the last singular values it saw for comparison.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/fixedpoint.jl#LL24-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.ctmrgstep-Tuple{CTMRGRuntime{SquareLattice,T,4,AT,CT,ET} where ET where CT where AT where T,Any}" href="#TensorNetworkAD.ctmrgstep-Tuple{CTMRGRuntime{SquareLattice,T,4,AT,CT,ET} where ET where CT where AT where T,Any}"><code>TensorNetworkAD.ctmrgstep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ctmrgstep(rt,vals)</code></pre><p>evaluate one step of the ctmrg-algorithm, returning a tuple of an updated <code>CTMRGRuntime</code> with updated <code>corner</code> and <code>edge</code> tensor and a vector of singular values to test convergence with.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ctmrg.jl#LL119-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.diaglocalhamiltonian-Tuple{Array{T,1} where T}" href="#TensorNetworkAD.diaglocalhamiltonian-Tuple{Array{T,1} where T}"><code>TensorNetworkAD.diaglocalhamiltonian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">diaglocalhamiltonian(diag::Vector)</code></pre><p>return the 2-site Hamiltonian with single-body terms given by the diagonal <code>diag</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/variationalipeps.jl#LL9-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.energy-Union{Tuple{T}, Tuple{AbstractArray{T,4},IPEPS}} where T" href="#TensorNetworkAD.energy-Union{Tuple{T}, Tuple{AbstractArray{T,4},IPEPS}} where T"><code>TensorNetworkAD.energy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">energy(h, ipeps; χ, tol, maxit)</code></pre><p>return the energy of the <code>ipeps</code> 2-site hamiltonian <code>h</code> and calculated via a ctmrg with parameters <code>χ</code>, <code>tol</code> and <code>maxit</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/variationalipeps.jl#LL22-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.expectationvalue-Union{Tuple{T}, Tuple{Any,Any,CTMRGRuntime{SquareLattice,T,4,AT,CT,ET} where ET where CT where AT where T}} where T" href="#TensorNetworkAD.expectationvalue-Union{Tuple{T}, Tuple{Any,Any,CTMRGRuntime{SquareLattice,T,4,AT,CT,ET} where ET where CT where AT where T}} where T"><code>TensorNetworkAD.expectationvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">expectationvalue(h, ap, rt)</code></pre><p>return the expectationvalue of a two-site operator <code>h</code> with the sites described by rank-6 tensor <code>ap</code> each and an environment described by a <code>SquareCTMRGRuntime</code> <code>rt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/variationalipeps.jl#LL42-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.fixedpoint-Tuple{Any,Any,Any}" href="#TensorNetworkAD.fixedpoint-Tuple{Any,Any,Any}"><code>TensorNetworkAD.fixedpoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fixedpoint(f, guess, stopfun)</code></pre><p>return the result of applying <code>guess = f(guess)</code> until convergence. Convergence is decided by applying <code>stopfun(guess)</code> which returns a Boolean.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/fixedpoint.jl#LL4-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.indexperm_symmetrize-Tuple{IPEPS{SquareLattice,T,5,AT} where AT&lt;:AbstractArray{T,5} where T}" href="#TensorNetworkAD.indexperm_symmetrize-Tuple{IPEPS{SquareLattice,T,5,AT} where AT&lt;:AbstractArray{T,5} where T}"><code>TensorNetworkAD.indexperm_symmetrize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">indexperm_symmetrize(ipeps::SquareIPEPS)</code></pre><p>return a <code>SquareIPEPS</code> based on <code>ipeps</code> that is symmetric under permutation of its virtual indices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/ipeps.jl#LL26-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.magnetisation-Union{Tuple{MT}, Tuple{MT,Any,Any}} where MT&lt;:TensorNetworkAD.HamiltonianModel" href="#TensorNetworkAD.magnetisation-Union{Tuple{MT}, Tuple{MT,Any,Any}} where MT&lt;:TensorNetworkAD.HamiltonianModel"><code>TensorNetworkAD.magnetisation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">magnetisation(model&lt;:HamiltonianModel, β, χ)</code></pre><p>return the magnetisation of the <code>model</code> as a function of the inverse temperature <code>β</code> and the environment bonddimension <code>χ</code> as calculated with ctmrg. Requires that <code>mag_tensor</code> and <code>model_tensor</code> are defined for <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/exampletensors.jl#LL50-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.magofβ-Tuple{Ising,Any}" href="#TensorNetworkAD.magofβ-Tuple{Ising,Any}"><code>TensorNetworkAD.magofβ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">magofβ(::Ising,β)</code></pre><p>return the analytical result for the magnetisation at inverse temperature <code>β</code> for the 2d classical ising model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/exampletensors.jl#LL71-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkAD.tensorfromclassical-Tuple{Array{T,2} where T}" href="#TensorNetworkAD.tensorfromclassical-Tuple{Array{T,2} where T}"><code>TensorNetworkAD.tensorfromclassical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensorfromclassical(h::Matrix)</code></pre><p>given a classical 2-body hamiltonian <code>h</code>, return the corresponding tensor for use in e.g. <code>trg</code> for a two-dimensional square-lattice.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model_tensor(Ising(),β) ≈ tensorfromclassical([β -β; -β β])

true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkAD.jl/blob/16601eb6c69f8174fb3c9b5ce75eec8c3eaba4f9/src/exampletensors.jl#LL4-L16">source</a></section><footer><hr/><a class="previous" href="../userguide/"><span class="direction">Previous</span><span class="title">User Guide</span></a><a class="next" href="../future/"><span class="direction">Next</span><span class="title">Future Directions</span></a></footer></article></body></html>
